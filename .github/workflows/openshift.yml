# Trigger the workflow on push to the main branch or manually
on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
  OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
  APP_NAME: "my-azure-function" # Application name
  APP_PORT: "8080" # Port your app listens to
  IMAGE_REGISTRY: "docker.io/mridul017" # Docker Hub username or other registry
  IMAGE_REGISTRY_USER: "mridul017"
  IMAGE_REGISTRY_PASSWORD: ${{ secrets.IMAGE_REGISTRY_PASSWORD }}
  IMAGE_TAGS: ${{ github.sha }} # Default tag using git commit hash

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-20.04

    steps:
      # Checkout repository
      - name: Check out the repository
        uses: actions/checkout@v4

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Install oc CLI (OpenShift)
      - name: Install oc CLI (OpenShift)
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          oc: 4.6.0

      # Build Docker image using Buildah
      - name: Build Docker image using Buildah
        id: build-image
        uses: redhat-actions/buildah-build@v2
        with:
          image: ${{ env.APP_NAME }}
          tags: ${{ env.IMAGE_TAGS }}
          dockerfiles: ./DrinkApp/Dockerfile  # Correct path to Dockerfile
          context: ./DrinkApp

      # Push the built Docker image to Docker Hub
      - name: Push Docker image to Docker Hub
        id: push-image
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.build-image.outputs.image }}
          tags: ${{ steps.build-image.outputs.tags }}
          registry: ${{ env.IMAGE_REGISTRY }}
          username: ${{ env.IMAGE_REGISTRY_USER }}
          password: ${{ secrets.IMAGE_REGISTRY_PASSWORD }}

  deploy-to-namespaces:
    name: Deploy to All OpenShift Namespaces
    needs: build-and-push
    runs-on: ubuntu-20.04
    strategy:
      matrix:
        namespace: ["kilo-dev"] #[ "kilo-dev", "kilo-qa", "kilo-prod" ] # Deploy to these namespaces

    env:
      OPENSHIFT_NAMESPACE: ${{ matrix.namespace }}

    steps:
      # Log in to OpenShift
      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          insecure_skip_tls_verify: true
          namespace: ${{ env.OPENSHIFT_NAMESPACE }}

      # Debug Image Path (optional for troubleshooting)
      - name: Debug Image Path
        run: |
          echo "Image path: ${{ steps.push-image.outputs.image }}"

      # Deploy the application and expose as a service
      - name: Create and expose OpenShift app
        id: deploy-and-expose
        uses: redhat-actions/oc-new-app@v1
        with:
          app_name: ${{ env.APP_NAME }}
          image: ${{ env.IMAGE_REGISTRY }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAGS }}
          namespace: ${{ env.OPENSHIFT_NAMESPACE }}
          port: ${{ env.APP_PORT }}
          
      # Set resource requests and limits
      - name: Set resource requests and limits
        run: |
          oc set resources deployment/${{ env.APP_NAME }} --requests=cpu=200m,memory=250Mi --limits=cpu=1,memory=1Gi -n ${{ env.OPENSHIFT_NAMESPACE }}   
          
      # Enable HTTPS for the Route
      - name: Enable HTTPS for the Route
        run: |
          oc patch route ${{ env.APP_NAME }} -n ${{ env.OPENSHIFT_NAMESPACE }} -p '{"spec":{"tls":{"termination":"edge"}}}'
          oc annotate route ${{ env.APP_NAME }} haproxy.router.openshift.io/redirect-to-https=true --overwrite

      # Set OpenAPI Hostnames (HTTPS)
      - name: Set OpenAPI Hostnames (HTTPS)
        run: |
          ROUTE=$(oc get route ${{ env.APP_NAME }} -o jsonpath='{.spec.host}')
          oc set env deployment/${{ env.APP_NAME }} OpenApi__HostNames=https://$ROUTE

      # Set environment variables for HTTPS
      - name: Set environment variables for HTTPS
        run: |
          oc set env deployment/${{ env.APP_NAME }} AzureFunctionsJobHost__Extensions__OpenApi__ForceHttps=true    

      # Scale the application to ensure multiple pods for load balancing
      - name: Scale Deployment
        run: |
          oc scale deployment/${{ env.APP_NAME }} --replicas=0

      # Set up Horizontal Pod Autoscaler (HPA)
      - name: Configure Horizontal Pod Autoscaler
        run: |
          if oc get hpa ${{ env.APP_NAME }} -n ${{ env.OPENSHIFT_NAMESPACE }} &>/dev/null; then
            oc delete hpa ${{ env.APP_NAME }} -n ${{ env.OPENSHIFT_NAMESPACE }}
          fi
          oc autoscale deployment/${{ env.APP_NAME }} --min=1 --max=2 --cpu-percent=70 -n ${{ env.OPENSHIFT_NAMESPACE }}

      # Wait for deployment rollout
      - name: Wait for Deployment Rollout
        run: |
          oc rollout status deployment/${{ env.APP_NAME }} --watch -n ${{ env.OPENSHIFT_NAMESPACE }}

      # Inject environment variables into deployment
      - name: Set environment variables
        run: |
          oc set env deployment/${{ env.APP_NAME }} dbkey=${{ secrets.DBKEY }} -n ${{ env.OPENSHIFT_NAMESPACE }}
          oc set env deployment/${{ env.APP_NAME }} DBURI=${{ secrets.DBURI }} -n ${{ env.OPENSHIFT_NAMESPACE }}
          oc set env deployment/${{ env.APP_NAME }} DBName=${{ secrets.DBNAME }} -n ${{ env.OPENSHIFT_NAMESPACE }}
          oc set env deployment/${{ env.APP_NAME }} Key="${{ secrets.KEY }}" -n ${{ env.OPENSHIFT_NAMESPACE }}
          oc set env deployment/${{ env.APP_NAME }} Issuer="${{ secrets.ISSUER }}" -n ${{ env.OPENSHIFT_NAMESPACE }}
          oc set env deployment/${{ env.APP_NAME }} Audience="${{ secrets.AUDIENCE }}" -n ${{ env.OPENSHIFT_NAMESPACE }}
          oc set env deployment/${{ env.APP_NAME }} SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }} -n ${{ env.OPENSHIFT_NAMESPACE }}
          oc set env deployment/${{ env.APP_NAME }} SENDER_ADDRESS=${{ secrets.SENDER_ADDRESS }} -n ${{ env.OPENSHIFT_NAMESPACE }}

      # Print application URL
      - name: Print Application URL
        run: |
          ROUTE=$(oc get route ${{ env.APP_NAME }} -n ${{ env.OPENSHIFT_NAMESPACE }} -o jsonpath='{.spec.host}')
          echo "Your app is available at: https://$ROUTE"
